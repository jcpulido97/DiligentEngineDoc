<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Diligent Engine</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-dark+documentation.compiled.css" />
  <link rel="icon" href="favicon-dark.png" type="image/png" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <a href="index.html" id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">Diligent Engine</a>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="pages.html">Pages</a></li>
            <li><a href="namespaces.html">Namespaces</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="3">
            <li><a href="annotated.html">Classes</a></li>
            <li><a href="files.html">Files</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          Diligent Engine
        </h1>
<p>This module implements <a href="https://github.com/DiligentGraphics/DiligentEngine">Diligent Engine</a>&#x27;s core functionality: Direct3D11, Direct3D12, OpenGL, OpenGLES, and Vulkan rendering backends as well as basic platform-specific utilities. It is self-contained and can be built by its own. The module&#x27;s cmake script defines a number of variables that are required to generate build files for other modules, so it must always be handled first.</p><section id="autotoc_md42"><h2><a href="#autotoc_md42">Table of Contents</a></h2><ul><li><a href="#clonning">Clonning the Repository</a></li><li><a href="#api_basics">API Basics</a><ul><li><a href="#initialization">Initializing the Engine</a><ul><li><a href="#initialization_win32">Win32</a></li><li><a href="#initialization_uwp">Universal Windows Platform</a></li><li><a href="#initialization_linux">Linux</a></li><li><a href="#initialization_macos">MacOS</a></li><li><a href="#initialization_ios">iOS</a></li><li><a href="#initialization_attaching">Attaching to Already Initialized Graphics API</a></li><li><a href="#initialization_destroying">Destroying the Engine</a></li></ul></li><li><a href="#creating_resources">Creating Resources</a></li><li><a href="#creating_shaders">Creating Shaders</a></li><li><a href="#initializing_pso">Initializing Pipeline State</a><ul><li><a href="#pipeline_resource_layout">Pipeline Resource Layout</a></li></ul></li><li><a href="#binding_resources">Binding Shader Resources</a></li><li><a href="#draw_command">Setting the Pipeline State and Invoking Draw Command</a></li></ul></li><li><a href="#low_level_api_interoperability">Low-level API interoperability</a></li><li><a href="#repository_structure">Repository structure</a></li><li><a href="#contributing">Contributing</a></li><li><a href="https://github.com/DiligentGraphics/DiligentCore#license">License</a></li><li><a href="#references">References</a></li><li><a href="#release_history">Release History</a></li></ul></section><section id="autotoc_md43"><h2><a href="#autotoc_md43">Cloning the Repository</a></h2><p>To get the repository and all submodules, use the following command:</p><pre class="m-code"><span class="n">git</span> <span class="n">clone</span> <span class="o">--</span><span class="n">recursive</span> <span class="nl">https</span><span class="p">:</span><span class="c1">//github.com/DiligentGraphics/DiligentCore.git</span></pre><p>To build the module, see <a href="https://github.com/DiligentGraphics/DiligentEngine/blob/master/README.md#build-and-run-instructions">build instructions</a> in the master repository.</p></section><section id="autotoc_md44"><h2><a href="#autotoc_md44">API Basics</a></h2><section id="autotoc_md45"><h3><a href="#autotoc_md45">Initializing the Engine</a></h3><p>Before you can use any functionality provided by the engine, you need to create a render device, an immediate context and a swap chain.</p><section id="autotoc_md46"><h4><a href="#autotoc_md46">Win32</a></h4><p>On Win32 platform, you can create OpenGL, Direct3D11, Direct3D12 or Vulkan device as shown below:</p><pre class="m-code"><span class="kt">void</span> <span class="nf">InitializeDiligentEngine</span><span class="p">(</span><span class="n">HWND</span> <span class="n">NativeWindowHandle</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SwapChainDesc</span> <span class="n">SCDesc</span><span class="p">;</span>
    <span class="n">SCDesc</span><span class="p">.</span><span class="n">SamplesCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">m_DeviceType</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="n">DeviceType</span><span class="o">::</span><span class="nl">D3D11</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="n">EngineD3D11CreateInfo</span> <span class="n">EngineCI</span><span class="p">;</span>
<span class="cp">#if ENGINE_DLL</span>
            <span class="n">GetEngineFactoryD3D11Type</span> <span class="n">GetEngineFactoryD3D11</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
            <span class="c1">// Load the dll and import GetEngineFactoryD3D11() function</span>
            <span class="n">LoadGraphicsEngineD3D11</span><span class="p">(</span><span class="n">GetEngineFactoryD3D11</span><span class="p">);</span>
<span class="cp">#endif</span>
            <span class="k">auto</span><span class="o">*</span> <span class="n">pFactoryD3D11</span> <span class="o">=</span> <span class="n">GetEngineFactoryD3D11</span><span class="p">();</span>
            <span class="n">pFactoryD3D11</span><span class="o">-&gt;</span><span class="n">CreateDeviceAndContextsD3D11</span><span class="p">(</span><span class="n">EngineCI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_pDevice</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_pImmediateContext</span><span class="p">);</span>
            <span class="n">pFactoryD3D11</span><span class="o">-&gt;</span><span class="n">CreateSwapChainD3D11</span><span class="p">(</span><span class="n">m_pDevice</span><span class="p">,</span> <span class="n">m_pImmediateContext</span><span class="p">,</span>
                                    <span class="n">SCDesc</span><span class="p">,</span> <span class="n">NativeWindowHandle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_pSwapChain</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="n">DeviceType</span><span class="o">::</span><span class="nl">D3D12</span><span class="p">:</span>
        <span class="p">{</span>
<span class="cp">#if ENGINE_DLL</span>
            <span class="n">GetEngineFactoryD3D12Type</span> <span class="n">GetEngineFactoryD3D12</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
            <span class="c1">// Load the dll and import GetEngineFactoryD3D12() function</span>
            <span class="n">LoadGraphicsEngineD3D12</span><span class="p">(</span><span class="n">GetEngineFactoryD3D12</span><span class="p">);</span>
<span class="cp">#endif</span>
            <span class="n">EngineD3D12CreateInfo</span> <span class="n">EngineCI</span><span class="p">;</span>
            <span class="k">auto</span><span class="o">*</span> <span class="n">pFactoryD3D12</span> <span class="o">=</span> <span class="n">GetEngineFactoryD3D12</span><span class="p">();</span>
            <span class="n">pFactoryD3D12</span><span class="o">-&gt;</span><span class="n">CreateDeviceAndContextsD3D12</span><span class="p">(</span><span class="n">EngineCI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_pDevice</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_pImmediateContext</span><span class="p">);</span>
            <span class="n">pFactoryD3D12</span><span class="o">-&gt;</span><span class="n">CreateSwapChainD3D12</span><span class="p">(</span><span class="n">m_pDevice</span><span class="p">,</span> <span class="n">m_pImmediateContext</span><span class="p">,</span>
                                    <span class="n">SCDesc</span><span class="p">,</span> <span class="n">NativeWindowHandle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_pSwapChain</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">DeviceType</span><span class="o">::</span><span class="nl">OpenGL</span><span class="p">:</span>
    <span class="p">{</span>

<span class="cp">#if ENGINE_DLL</span>
        <span class="c1">// Declare function pointer</span>
        <span class="n">GetEngineFactoryOpenGLType</span> <span class="n">GetEngineFactoryOpenGL</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="c1">// Load the dll and import GetEngineFactoryOpenGL() function</span>
        <span class="n">LoadGraphicsEngineOpenGL</span><span class="p">(</span><span class="n">GetEngineFactoryOpenGL</span><span class="p">);</span>
<span class="cp">#endif</span>
        <span class="k">auto</span><span class="o">*</span> <span class="n">pFactoryOpenGL</span> <span class="o">=</span> <span class="n">GetEngineFactoryOpenGL</span><span class="p">();</span>
        <span class="n">EngineGLCreateInfo</span> <span class="n">EngineCI</span><span class="p">;</span>
        <span class="n">EngineCI</span><span class="p">.</span><span class="n">Window</span><span class="p">.</span><span class="n">hWnd</span> <span class="o">=</span> <span class="n">NativeWindowHandle</span><span class="p">;</span>
        <span class="n">pFactoryOpenGL</span><span class="o">-&gt;</span><span class="n">CreateDeviceAndSwapChainGL</span><span class="p">(</span>
            <span class="n">EngineCI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_pDevice</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_pImmediateContext</span><span class="p">,</span> <span class="n">SCDesc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_pSwapChain</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">DeviceType</span><span class="o">::</span><span class="nl">Vulkan</span><span class="p">:</span>
    <span class="p">{</span>
<span class="cp">#if ENGINE_DLL</span>
        <span class="n">GetEngineFactoryVkType</span> <span class="n">GetEngineFactoryVk</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="c1">// Load the dll and import GetEngineFactoryVk() function</span>
        <span class="n">LoadGraphicsEngineVk</span><span class="p">(</span><span class="n">GetEngineFactoryVk</span><span class="p">);</span>
<span class="cp">#endif</span>
        <span class="n">EngineVkCreateInfo</span> <span class="n">EngineCI</span><span class="p">;</span>
        <span class="k">auto</span><span class="o">*</span> <span class="n">pFactoryVk</span> <span class="o">=</span> <span class="n">GetEngineFactoryVk</span><span class="p">();</span>
        <span class="n">pFactoryVk</span><span class="o">-&gt;</span><span class="n">CreateDeviceAndContextsVk</span><span class="p">(</span><span class="n">EngineCI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_pDevice</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_pImmediateContext</span><span class="p">);</span>
        <span class="n">pFactoryVk</span><span class="o">-&gt;</span><span class="n">CreateSwapChainVk</span><span class="p">(</span><span class="n">m_pDevice</span><span class="p">,</span> <span class="n">m_pImmediateContext</span><span class="p">,</span>
                                      <span class="n">SCDesc</span><span class="p">,</span> <span class="n">NativeWindowHandle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_pSwapChain</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">break</span><span class="p">;</span>

    <span class="k">default</span><span class="o">:</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Unknown device type&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></pre><p>On Windows, the engine can be statically linked to the application or built as a separate DLL. In the former case, factory functions <code><a href="namespaceDiligent.html#af9b305ae08df97d420451caf307d520e" class="m-doc">GetEngineFactoryOpenGL()</a></code>, <code><a href="namespaceDiligent.html#a5422edb2b4c0ac68fb9eb9b4a81cd3a5" class="m-doc">GetEngineFactoryD3D11()</a></code>, <code><a href="namespaceDiligent.html#a17983a17c4980162c8401f4c35906484" class="m-doc">GetEngineFactoryD3D12()</a></code>, and <code><a href="namespaceDiligent.html#af2f055f8e4989778afb9e87d277475e4" class="m-doc">GetEngineFactoryVk()</a></code> can be called directly. In the latter case, you need to load the DLL into the process&#x27;s address space using <code>LoadGraphicsEngineOpenGL()</code>, <code>LoadGraphicsEngineD3D11()</code>, <code>LoadGraphicsEngineD3D12()</code>, or <code>LoadGraphicsEngineVk()</code> function. Each function loads appropriate dynamic library and imports the functions required to initialize the engine. You need to include the following headers:</p><pre class="m-code"><span class="cp">#include</span> <span class="cpf">&quot;EngineFactoryD3D11.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;EngineFactoryD3D12.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;EngineFactoryOpenGL.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;EngineFactoryVk.h&quot;</span><span class="cp"></span></pre><p>You also need to add the following directories to the include search paths:</p><ul><li>DiligentCore/Graphics/GraphicsEngineD3D11/interface</li><li>DiligentCore/Graphics/GraphicsEngineD3D12/interface</li><li>DiligentCore/Graphics/GraphicsEngineOpenGL/interface</li><li>DiligentCore/Graphics/GraphicsEngineVulkan/interface</li></ul><p>Also, enable <a href="namespaceDiligent.html" class="m-doc">Diligent</a> namespace:</p><pre class="m-code"><span class="k">using</span> <span class="k">namespace</span> <span class="n">Diligent</span><span class="p">;</span></pre><p><code>IEngineFactoryD3D11::CreateDeviceAndContextsD3D11()</code>, <code>IEngineFactoryD3D12::CreateDeviceAndContextsD3D12()</code>, and <code>IEngineFactoryVk::CreateDeviceAndContextsVk()</code> functions can also create a specified number of deferred contexts, which can be used for multi-threaded command recording. Deferred contexts can only be created during the initialization of the engine. The function populates an array of pointers to the contexts, where the immediate context goes at position 0, followed by all deferred contexts.</p><p>For more details, take a look at <a href="https://github.com/DiligentGraphics/DiligentSamples/blob/master/Tutorials/Tutorial00_HelloWin32/src/Tutorial00_HelloWin32.cpp">Tutorial00_<wbr />HelloWin32.cpp</a> file.</p></section><section id="autotoc_md47"><h4><a href="#autotoc_md47">Universal Windows Platform</a></h4><p>On Universal Windows Platform, you can create Direct3D11 or Direct3D12 device. Only static linking is currently supported, but dynamic linking can also be implemented. Initialization is performed the same way as on Win32 Platform. The difference is that you first create the render device and device contexts by calling <code>IEngineFactoryD3D11::CreateDeviceAndContextsD3D11()</code> or <code>IEngineFactoryD3D12::CreateDeviceAndContextsD3D12()</code>. The swap chain is created later by a call to <code>IEngineFactoryD3D11::CreateSwapChainD3D11()</code> or <code>IEngineFactoryD3D12::CreateSwapChainD3D12()</code>. Please look at <a href="https://github.com/DiligentGraphics/DiligentSamples/blob/master/SampleBase/src/UWP/SampleAppUWP.cpp">SampleAppUWP.cpp</a> file for more details.</p><p><a name="initialization_linux"></a></p></section><section id="autotoc_md48"><h4><a href="#autotoc_md48">Linux</a></h4><p>On Linux platform, the engine supports OpenGL and Vulkan backends. Initialization of GL context on Linux is tightly coupled with window creation. As a result, <a href="namespaceDiligent.html" class="m-doc">Diligent</a> Engine does not initialize the context, but attaches to the one initialized by the app. An example of the engine initialization on Linux can be found in <a href="https://github.com/DiligentGraphics/DiligentSamples/blob/master/Tutorials/Tutorial00_HelloLinux/src/Tutorial00_HelloLinux.cpp">Tutorial00_<wbr />HelloLinux.cpp</a>.</p><p><a name="initialization_macos"></a></p></section><section id="autotoc_md49"><h4><a href="#autotoc_md49">MacOS</a></h4><p>On MacOS, <a href="namespaceDiligent.html" class="m-doc">Diligent</a> Engine supports OpenGL, Vulkan and Metal backends. Initialization of GL context on MacOS is performed by the application, and the engine attaches to the context created by the app; see <a href="https://github.com/DiligentGraphics/DiligentTools/blob/master/NativeApp/Apple/Source/Classes/OSX/GLView.m">GLView.m</a> for details. Vulkan backend is initialized similar to other platforms. See <a href="https://github.com/DiligentGraphics/DiligentTools/blob/master/NativeApp/Apple/Source/Classes/OSX/MetalView.m">MetalView.m</a>.</p><p><a name="initialization_android"></a></p></section><section id="autotoc_md50"><h4><a href="#autotoc_md50">Android</a></h4><p>On Android, you can create OpenGLES or Vulkan device. The following code snippet shows an example:</p><pre class="m-code"><span class="k">auto</span><span class="o">*</span> <span class="n">pFactoryOpenGL</span> <span class="o">=</span> <span class="n">GetEngineFactoryOpenGL</span><span class="p">();</span>
<span class="n">EngineGLCreateInfo</span> <span class="n">EngineCI</span><span class="p">;</span>
<span class="n">EngineCI</span><span class="p">.</span><span class="n">Window</span><span class="p">.</span><span class="n">pAWindow</span> <span class="o">=</span> <span class="n">NativeWindowHandle</span><span class="p">;</span>
<span class="n">pFactoryOpenGL</span><span class="o">-&gt;</span><span class="n">CreateDeviceAndSwapChainGL</span><span class="p">(</span>
    <span class="n">EngineCI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_pDevice</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_pContext</span><span class="p">,</span> <span class="n">SCDesc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_pSwapChain</span><span class="p">);</span>
<span class="n">IRenderDeviceGLES</span> <span class="o">*</span><span class="n">pRenderDeviceOpenGLES</span><span class="p">;</span>
<span class="n">pRenderDevice</span><span class="o">-&gt;</span><span class="n">QueryInterface</span><span class="p">(</span><span class="n">IID_RenderDeviceGLES</span><span class="p">,</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">IObject</span><span class="o">**&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pRenderDeviceOpenGLES</span><span class="p">));</span></pre><p>If engine is built as dynamic library, the library needs to be loaded by the native activity. The following code shows one possible way:</p><pre class="m-code"><span class="kd">static</span>
<span class="o">{</span>
    <span class="k">try</span><span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">loadLibrary</span><span class="o">(</span><span class="s">&quot;GraphicsEngineOpenGL&quot;</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">UnsatisfiedLinkError</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Log</span><span class="o">.</span><span class="na">e</span><span class="o">(</span><span class="s">&quot;native-activity&quot;</span><span class="o">,</span> <span class="s">&quot;Failed to load GraphicsEngineOpenGL library.\n&quot;</span> <span class="o">+</span> <span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></pre><p><a name="initialization_ios"></a></p></section><section id="autotoc_md51"><h4><a href="#autotoc_md51">iOS</a></h4><p>iOS implementation supports OpenGLES and Metal backend. Initialization of GL context on iOS is performed by the application, and the engine attaches to the context initialized by the app; see <a href="https://github.com/DiligentGraphics/DiligentTools/blob/master/NativeApp/Apple/Source/Classes/iOS/EAGLView.m">EAGLView.m</a> for details.</p><p><a name="initialization_attaching"></a></p></section><section id="autotoc_md52"><h4><a href="#autotoc_md52">Attaching to Already Initialized Graphics API</a></h4><p>An alternative way to initialize the engine is to attach to existing D3D11/D3D12 device or OpenGL/GLES context. Refer to <a href="http://diligentgraphics.com/diligent-engine/native-api-interoperability/">Native API interoperability</a> for more details.</p><p><a name="initialization_destroying"></a></p></section><section id="autotoc_md53"><h4><a href="#autotoc_md53">Destroying the Engine</a></h4><p>The engine performs automatic reference counting and shuts down when the last reference to an engine object is released.</p><p><a name="creating_resources"></a></p></section></section><section id="autotoc_md54"><h3><a href="#autotoc_md54">Creating Resources</a></h3><p>Device resources are created by the render device. The two main resource types are buffers, which represent linear memory, and textures, which use memory layouts optimized for fast filtering. To create a buffer, you need to populate <code>BufferDesc</code> structure and call <code>IRenderDevice::CreateBuffer()</code>. The following code creates a uniform (constant) buffer:</p><pre class="m-code"><span class="n">BufferDesc</span> <span class="n">BuffDesc</span><span class="p">;</span>
<span class="n">BuffDesc</span><span class="p">.</span><span class="n">Name</span>           <span class="o">=</span> <span class="s">&quot;Uniform buffer&quot;</span><span class="p">;</span>
<span class="n">BuffDesc</span><span class="p">.</span><span class="n">BindFlags</span>      <span class="o">=</span> <span class="n">BIND_UNIFORM_BUFFER</span><span class="p">;</span>
<span class="n">BuffDesc</span><span class="p">.</span><span class="n">Usage</span>          <span class="o">=</span> <span class="n">USAGE_DYNAMIC</span><span class="p">;</span>
<span class="n">BuffDesc</span><span class="p">.</span><span class="n">uiSizeInBytes</span>  <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ShaderConstants</span><span class="p">);</span>
<span class="n">BuffDesc</span><span class="p">.</span><span class="n">CPUAccessFlags</span> <span class="o">=</span> <span class="n">CPU_ACCESS_WRITE</span><span class="p">;</span>
<span class="n">m_pDevice</span><span class="o">-&gt;</span><span class="n">CreateBuffer</span><span class="p">(</span><span class="n">BuffDesc</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_pConstantBuffer</span><span class="p">);</span></pre><p>Similar, to create a texture, populate <code>TextureDesc</code> structure and call <code>IRenderDevice::CreateTexture()</code> as in the following example:</p><pre class="m-code"><span class="n">TextureDesc</span> <span class="n">TexDesc</span><span class="p">;</span>
<span class="n">TexDesc</span><span class="p">.</span><span class="n">Name</span>      <span class="o">=</span> <span class="s">&quot;My texture 2D&quot;</span><span class="p">;</span>
<span class="n">TexDesc</span><span class="p">.</span><span class="n">Type</span>      <span class="o">=</span> <span class="n">TEXTURE_TYPE_2D</span><span class="p">;</span>
<span class="n">TexDesc</span><span class="p">.</span><span class="n">Width</span>     <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
<span class="n">TexDesc</span><span class="p">.</span><span class="n">Height</span>    <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
<span class="n">TexDesc</span><span class="p">.</span><span class="n">Format</span>    <span class="o">=</span> <span class="n">TEX_FORMAT_RGBA8_UNORM</span><span class="p">;</span>
<span class="n">TexDesc</span><span class="p">.</span><span class="n">Usage</span>     <span class="o">=</span> <span class="n">USAGE_DEFAULT</span><span class="p">;</span>
<span class="n">TexDesc</span><span class="p">.</span><span class="n">BindFlags</span> <span class="o">=</span> <span class="n">BIND_SHADER_RESOURCE</span> <span class="o">|</span> <span class="n">BIND_RENDER_TARGET</span> <span class="o">|</span> <span class="n">BIND_UNORDERED_ACCESS</span><span class="p">;</span>
<span class="n">TexDesc</span><span class="p">.</span><span class="n">Name</span> <span class="o">=</span> <span class="s">&quot;Sample 2D Texture&quot;</span><span class="p">;</span>
<span class="n">m_pRenderDevice</span><span class="o">-&gt;</span><span class="n">CreateTexture</span><span class="p">(</span><span class="n">TexDesc</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_pTestTex</span><span class="p">);</span></pre><p>There is only one function <code>CreateTexture()</code> that is capable of creating all types of textures. Type, format, array size and all other parameters are specified by the members of the <code>TextureDesc</code> structure.</p><p>For every bind flag specified during the texture creation time, the texture object creates a default view. Default shader resource view addresses the entire texture, default render target and depth stencil views reference all array slices in the most detailed mip level, and unordered access view references the entire texture. To get a default view from the texture, use <code>ITexture::GetDefaultView()</code> function. Note that this function does not increment the reference counter on the returned interface. You can create additional texture views using <code>ITexture::CreateView()</code>. Use <code>IBuffer::CreateView()</code> to create additional views of a buffer.</p><p><a name="creating_shaders"></a></p></section><section id="autotoc_md55"><h3><a href="#autotoc_md55">Creating Shaders</a></h3><p>To create a shader, populate <code>ShaderCreateInfo</code> structure:</p><pre class="m-code"><span class="n">ShaderCreateInfo</span> <span class="n">ShaderCI</span><span class="p">;</span></pre><p>There are two ways to create a shader. The first way is to provide a pointer to the shader source code through <code>ShaderCreateInfo::Source</code> member. The second way is to provide a file name. Graphics Engine is entirely decoupled from the platform. Since the host file system is platform-dependent, the structure exposes <code>ShaderCreateInfo::pShaderSourceStreamFactory</code> member that is intended to give the engine access to the file system. If you provided the source file name, you must also provide a non-null pointer to the shader source stream factory. If the shader source contains any <code>#include</code> directives, the source stream factory will also be used to load these files. The engine provides default implementation for every supported platform that should be sufficient in most cases. You can however define your own implementation.</p><p>An important member is <code>ShaderCreateInfo::SourceLanguage</code>. The following are valid values for this member:</p><ul><li><code>SHADER_SOURCE_LANGUAGE_DEFAULT</code> - The shader source format matches the underlying graphics API: HLSL for D3D11 or D3D12 mode, and GLSL for OpenGL, OpenGLES, and Vulkan modes.</li><li><code>SHADER_SOURCE_LANGUAGE_HLSL</code> - The shader source is in HLSL. For OpenGL and OpenGLES modes, the source code will be converted to GLSL. In Vulkan back-end, the code will be compiled to SPIRV directly.</li><li><code>SHADER_SOURCE_LANGUAGE_GLSL</code> - The shader source is in GLSL.</li></ul><p>Other members of the <code>ShaderCreateInfo</code> structure define shader include search directories, shader macro definitions, shader entry point and other parameters.</p><pre class="m-code"><span class="n">ShaderMacroHelper</span> <span class="n">Macros</span><span class="p">;</span>
<span class="n">Macros</span><span class="p">.</span><span class="n">AddShaderMacro</span><span class="p">(</span><span class="s">&quot;USE_SHADOWS&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">Macros</span><span class="p">.</span><span class="n">AddShaderMacro</span><span class="p">(</span><span class="s">&quot;NUM_SHADOW_SAMPLES&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="n">Macros</span><span class="p">.</span><span class="n">Finalize</span><span class="p">();</span>
<span class="n">ShaderCI</span><span class="p">.</span><span class="n">Macros</span> <span class="o">=</span> <span class="n">Macros</span><span class="p">;</span></pre><p>When everything is ready, call <code>IRenderDevice::CreateShader()</code> to create the shader object:</p><pre class="m-code"><span class="n">ShaderCreateInfo</span> <span class="n">ShaderCI</span><span class="p">;</span>
<span class="n">ShaderCI</span><span class="p">.</span><span class="n">Desc</span><span class="p">.</span><span class="n">Name</span>         <span class="o">=</span> <span class="s">&quot;MyPixelShader&quot;</span><span class="p">;</span>
<span class="n">ShaderCI</span><span class="p">.</span><span class="n">FilePath</span>          <span class="o">=</span> <span class="s">&quot;MyShaderFile.fx&quot;</span><span class="p">;</span>
<span class="n">ShaderCI</span><span class="p">.</span><span class="n">EntryPoint</span>        <span class="o">=</span> <span class="s">&quot;MyPixelShader&quot;</span><span class="p">;</span>
<span class="n">ShaderCI</span><span class="p">.</span><span class="n">Desc</span><span class="p">.</span><span class="n">ShaderType</span>   <span class="o">=</span> <span class="n">SHADER_TYPE_PIXEL</span><span class="p">;</span>
<span class="n">ShaderCI</span><span class="p">.</span><span class="n">SourceLanguage</span>    <span class="o">=</span> <span class="n">SHADER_SOURCE_LANGUAGE_HLSL</span><span class="p">;</span>
<span class="k">const</span> <span class="k">auto</span><span class="o">*</span> <span class="n">SearchDirectories</span> <span class="o">=</span> <span class="s">&quot;shaders;shaders</span><span class="se">\\</span><span class="s">inc;&quot;</span><span class="p">;</span>
<span class="n">RefCntAutoPtr</span><span class="o">&lt;</span><span class="n">IShaderSourceInputStreamFactory</span><span class="o">&gt;</span> <span class="n">pShaderSourceFactory</span><span class="p">;</span>
<span class="n">m_pEngineFactory</span><span class="o">-&gt;</span><span class="n">CreateDefaultShaderSourceStreamFactory</span><span class="p">(</span><span class="n">SearchDirectories</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pShaderSourceFactory</span><span class="p">);</span>
<span class="n">ShaderCI</span><span class="p">.</span><span class="n">pShaderSourceStreamFactory</span> <span class="o">=</span> <span class="n">pShaderSourceFactory</span><span class="p">;</span>
<span class="n">RefCntAutoPtr</span><span class="o">&lt;</span><span class="n">IShader</span><span class="o">&gt;</span> <span class="n">pShader</span><span class="p">;</span>
<span class="n">m_pDevice</span><span class="o">-&gt;</span><span class="n">CreateShader</span><span class="p">(</span><span class="n">ShaderCI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pShader</span><span class="p">);</span></pre><p><a name="initializing_pso"></a></p></section><section id="autotoc_md56"><h3><a href="#autotoc_md56">Initializing Pipeline State</a></h3><p><a href="namespaceDiligent.html" class="m-doc">Diligent</a> Engine follows Direct3D12/Vulkan style to configure the graphics/compute pipeline. One monolithic Pipelines State Object (PSO) encompasses all required states (all shader stages, input layout description, depth stencil, rasterizer and blend state descriptions etc.). To create a pipeline state object, define an instance of <code>GraphicsPipelineStateCreateInfo</code> structure:</p><pre class="m-code"><span class="n">GraphicsPipelineStateCreateInfo</span> <span class="n">PSOCreateInfo</span><span class="p">;</span>
<span class="n">PipelineStateDesc</span><span class="o">&amp;</span>              <span class="n">PSODesc</span> <span class="o">=</span> <span class="n">PSOCreateInfo</span><span class="p">.</span><span class="n">PSODesc</span><span class="p">;</span>

<span class="n">PSODesc</span><span class="p">.</span><span class="n">Name</span> <span class="o">=</span> <span class="s">&quot;My pipeline state&quot;</span><span class="p">;</span></pre><p>Describe the pipeline specifics such as if the pipeline is a compute pipeline, number and format of render targets as well as depth-stencil format:</p><pre class="m-code"><span class="c1">// This is a graphics pipeline</span>
<span class="n">PSODesc</span><span class="p">.</span><span class="n">PipelineType</span>                            <span class="o">=</span> <span class="n">PIPELINE_TYPE_GRAPHICS</span><span class="p">;</span>
<span class="n">PSOCreateInfo</span><span class="p">.</span><span class="n">GraphicsPipeline</span><span class="p">.</span><span class="n">NumRenderTargets</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">PSOCreateInfo</span><span class="p">.</span><span class="n">GraphicsPipeline</span><span class="p">.</span><span class="n">RTVFormats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    <span class="o">=</span> <span class="n">TEX_FORMAT_RGBA8_UNORM_SRGB</span><span class="p">;</span>
<span class="n">PSOCreateInfo</span><span class="p">.</span><span class="n">GraphicsPipeline</span><span class="p">.</span><span class="n">DSVFormat</span>        <span class="o">=</span> <span class="n">TEX_FORMAT_D32_FLOAT</span><span class="p">;</span></pre><p>Initialize depth-stencil state description structure DepthStencilStateDesc. Note that the constructor initializes the members with default values and you may only set the ones that are different from default.</p><pre class="m-code"><span class="c1">// Init depth-stencil state</span>
<span class="n">DepthStencilStateDesc</span><span class="o">&amp;</span> <span class="n">DepthStencilDesc</span> <span class="o">=</span> <span class="n">PSOCreateInfo</span><span class="p">.</span><span class="n">GraphicsPipeline</span><span class="p">.</span><span class="n">DepthStencilDesc</span><span class="p">;</span>
<span class="n">DepthStencilDesc</span><span class="p">.</span><span class="n">DepthEnable</span>            <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">DepthStencilDesc</span><span class="p">.</span><span class="n">DepthWriteEnable</span>       <span class="o">=</span> <span class="nb">true</span><span class="p">;</span></pre><p>Initialize blend state description structure <code>BlendStateDesc</code>:</p><pre class="m-code"><span class="c1">// Init blend state</span>
<span class="n">BlendStateDesc</span><span class="o">&amp;</span> <span class="n">BSDesc</span> <span class="o">=</span> <span class="n">PSOCreateInfo</span><span class="p">.</span><span class="n">GraphicsPipeline</span><span class="p">.</span><span class="n">BlendDesc</span><span class="p">;</span>
<span class="n">BSDesc</span><span class="p">.</span><span class="n">IndependentBlendEnable</span> <span class="o">=</span> <span class="n">False</span><span class="p">;</span>
<span class="k">auto</span> <span class="o">&amp;</span><span class="n">RT0</span> <span class="o">=</span> <span class="n">BSDesc</span><span class="p">.</span><span class="n">RenderTargets</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">RT0</span><span class="p">.</span><span class="n">BlendEnable</span>           <span class="o">=</span> <span class="n">True</span><span class="p">;</span>
<span class="n">RT0</span><span class="p">.</span><span class="n">RenderTargetWriteMask</span> <span class="o">=</span> <span class="n">COLOR_MASK_ALL</span><span class="p">;</span>
<span class="n">RT0</span><span class="p">.</span><span class="n">SrcBlend</span>              <span class="o">=</span> <span class="n">BLEND_FACTOR_SRC_ALPHA</span><span class="p">;</span>
<span class="n">RT0</span><span class="p">.</span><span class="n">DestBlend</span>             <span class="o">=</span> <span class="n">BLEND_FACTOR_INV_SRC_ALPHA</span><span class="p">;</span>
<span class="n">RT0</span><span class="p">.</span><span class="n">BlendOp</span>               <span class="o">=</span> <span class="n">BLEND_OPERATION_ADD</span><span class="p">;</span>
<span class="n">RT0</span><span class="p">.</span><span class="n">SrcBlendAlpha</span>         <span class="o">=</span> <span class="n">BLEND_FACTOR_SRC_ALPHA</span><span class="p">;</span>
<span class="n">RT0</span><span class="p">.</span><span class="n">DestBlendAlpha</span>        <span class="o">=</span> <span class="n">BLEND_FACTOR_INV_SRC_ALPHA</span><span class="p">;</span>
<span class="n">RT0</span><span class="p">.</span><span class="n">BlendOpAlpha</span>          <span class="o">=</span> <span class="n">BLEND_OPERATION_ADD</span><span class="p">;</span></pre><p>Initialize rasterizer state description structure <code>RasterizerStateDesc</code>:</p><pre class="m-code"><span class="c1">// Init rasterizer state</span>
<span class="n">RasterizerStateDesc</span><span class="o">&amp;</span> <span class="n">RasterizerDesc</span> <span class="o">=</span> <span class="n">PSOCreateInfo</span><span class="p">.</span><span class="n">GraphicsPipeline</span><span class="p">.</span><span class="n">RasterizerDesc</span><span class="p">;</span>
<span class="n">RasterizerDesc</span><span class="p">.</span><span class="n">FillMode</span>              <span class="o">=</span> <span class="n">FILL_MODE_SOLID</span><span class="p">;</span>
<span class="n">RasterizerDesc</span><span class="p">.</span><span class="n">CullMode</span>              <span class="o">=</span> <span class="n">CULL_MODE_NONE</span><span class="p">;</span>
<span class="n">RasterizerDesc</span><span class="p">.</span><span class="n">FrontCounterClockwise</span> <span class="o">=</span> <span class="n">True</span><span class="p">;</span>
<span class="n">RasterizerDesc</span><span class="p">.</span><span class="n">ScissorEnable</span>         <span class="o">=</span> <span class="n">True</span><span class="p">;</span>
<span class="n">RasterizerDesc</span><span class="p">.</span><span class="n">AntialiasedLineEnable</span> <span class="o">=</span> <span class="n">False</span><span class="p">;</span></pre><p>Initialize input layout description structure <code>InputLayoutDesc</code>:</p><pre class="m-code"><span class="c1">// Define input layout</span>
<span class="n">InputLayoutDesc</span><span class="o">&amp;</span> <span class="n">Layout</span> <span class="o">=</span> <span class="n">PSOCreateInfo</span><span class="p">.</span><span class="n">GraphicsPipeline</span><span class="p">.</span><span class="n">InputLayout</span><span class="p">;</span>
<span class="n">LayoutElement</span> <span class="n">LayoutElems</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="n">LayoutElement</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">VT_FLOAT32</span><span class="p">,</span> <span class="n">False</span> <span class="p">),</span>
    <span class="n">LayoutElement</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">VT_UINT8</span><span class="p">,</span>   <span class="n">True</span> <span class="p">),</span>
    <span class="n">LayoutElement</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">VT_FLOAT32</span><span class="p">,</span> <span class="n">False</span> <span class="p">),</span>
<span class="p">};</span>
<span class="n">Layout</span><span class="p">.</span><span class="n">LayoutElements</span> <span class="o">=</span> <span class="n">LayoutElems</span><span class="p">;</span>
<span class="n">Layout</span><span class="p">.</span><span class="n">NumElements</span>    <span class="o">=</span> <span class="n">_countof</span><span class="p">(</span><span class="n">LayoutElems</span><span class="p">);</span></pre><p>Define primitive topology and set shader pointers:</p><pre class="m-code"><span class="c1">// Define shader and primitive topology</span>
<span class="n">PSOCreateInfo</span><span class="p">.</span><span class="n">GraphicsPipeline</span><span class="p">.</span><span class="n">PrimitiveTopology</span> <span class="o">=</span> <span class="n">PRIMITIVE_TOPOLOGY_TRIANGLE_LIST</span><span class="p">;</span>
<span class="n">PSOCreateInfo</span><span class="p">.</span><span class="n">pVS</span> <span class="o">=</span> <span class="n">m_pVS</span><span class="p">;</span>
<span class="n">PSOCreateInfo</span><span class="p">.</span><span class="n">pPS</span> <span class="o">=</span> <span class="n">m_pPS</span><span class="p">;</span></pre><p><a name="pipeline_resource_layout"></a></p><section id="autotoc_md57"><h4><a href="#autotoc_md57">Pipeline Resource Layout</a></h4><p>Pipeline resource layout informs the engine how the application is going to use different shader resource variables. To allow grouping of resources based on the frequency of expected change, <a href="namespaceDiligent.html" class="m-doc">Diligent</a> Engine introduces classification of shader variables:</p><ul><li><strong>Static variables</strong> (<code>SHADER_RESOURCE_VARIABLE_TYPE_STATIC</code>) are variables that are expected to be set only once. They may not be changed once a resource is bound to the variable. Such variables are intended to hold global constants such as camera attributes or global light attributes constant buffers.</li><li><strong>Mutable variables</strong> (<code>SHADER_RESOURCE_VARIABLE_TYPE_MUTABLE</code>) define resources that are expected to change on a per-material frequency. Examples may include diffuse textures, normal maps etc.</li><li><strong>Dynamic variables</strong> (<code>SHADER_RESOURCE_VARIABLE_TYPE_DYNAMIC</code>) are expected to change frequently and randomly.</li></ul><p>To define variable types, prepare an array of <code>ShaderResourceVariableDesc</code> structures and initialize <code>PSODesc.ResourceLayout.Variables</code> and <code>PSODesc.ResourceLayout.NumVariables</code> members. Also <code>PSODesc.ResourceLayout.DefaultVariableType</code> can be used to set the type that will be used if a variable name is not provided.</p><pre class="m-code"><span class="n">ShaderResourceVariableDesc</span> <span class="n">ShaderVars</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">{</span><span class="n">SHADER_TYPE_PIXEL</span><span class="p">,</span> <span class="s">&quot;g_StaticTexture&quot;</span><span class="p">,</span>  <span class="n">SHADER_RESOURCE_VARIABLE_TYPE_STATIC</span><span class="p">},</span>
    <span class="p">{</span><span class="n">SHADER_TYPE_PIXEL</span><span class="p">,</span> <span class="s">&quot;g_MutableTexture&quot;</span><span class="p">,</span> <span class="n">SHADER_RESOURCE_VARIABLE_TYPE_MUTABLE</span><span class="p">},</span>
    <span class="p">{</span><span class="n">SHADER_TYPE_PIXEL</span><span class="p">,</span> <span class="s">&quot;g_DynamicTexture&quot;</span><span class="p">,</span> <span class="n">SHADER_RESOURCE_VARIABLE_TYPE_DYNAMIC</span><span class="p">}</span>
<span class="p">};</span>
<span class="n">PSODesc</span><span class="p">.</span><span class="n">ResourceLayout</span><span class="p">.</span><span class="n">Variables</span>           <span class="o">=</span> <span class="n">ShaderVars</span><span class="p">;</span>
<span class="n">PSODesc</span><span class="p">.</span><span class="n">ResourceLayout</span><span class="p">.</span><span class="n">NumVariables</span>        <span class="o">=</span> <span class="n">_countof</span><span class="p">(</span><span class="n">ShaderVars</span><span class="p">);</span>
<span class="n">PSODesc</span><span class="p">.</span><span class="n">ResourceLayout</span><span class="p">.</span><span class="n">DefaultVariableType</span> <span class="o">=</span> <span class="n">SHADER_RESOURCE_VARIABLE_TYPE_STATIC</span><span class="p">;</span></pre><p>When creating a pipeline state, textures can be permanently assigned static samplers. If a static sampler is assigned to a texture, it will always be used instead of the one initialized in the texture shader resource view. To define static samplers, prepare an array of <code>StaticSamplerDesc</code> structures and intialize <code>PSODesc.ResourceLayout.StaticSamplers</code> and <code>PSODesc.ResourceLayout.NumStaticSamplers</code> members. Notice that static samplers can be assigned to a texture variable of any type, not necessarily static, so that the texture binding can be changed at run-time, while the sampler will stay immutable. It is highly recommended to use static samplers whenever possible.</p><pre class="m-code"><span class="n">StaticSamplerDesc</span> <span class="n">StaticSampler</span><span class="p">;</span>
<span class="n">StaticSampler</span><span class="p">.</span><span class="n">ShaderStages</span>   <span class="o">=</span> <span class="n">SHADER_TYPE_PIXEL</span><span class="p">;</span>
<span class="n">StaticSampler</span><span class="p">.</span><span class="n">Desc</span><span class="p">.</span><span class="n">MinFilter</span> <span class="o">=</span> <span class="n">FILTER_TYPE_LINEAR</span><span class="p">;</span>
<span class="n">StaticSampler</span><span class="p">.</span><span class="n">Desc</span><span class="p">.</span><span class="n">MagFilter</span> <span class="o">=</span> <span class="n">FILTER_TYPE_LINEAR</span><span class="p">;</span>
<span class="n">StaticSampler</span><span class="p">.</span><span class="n">Desc</span><span class="p">.</span><span class="n">MipFilter</span> <span class="o">=</span> <span class="n">FILTER_TYPE_LINEAR</span><span class="p">;</span>
<span class="n">StaticSampler</span><span class="p">.</span><span class="n">TextureName</span>    <span class="o">=</span> <span class="s">&quot;g_MutableTexture&quot;</span><span class="p">;</span>
<span class="n">PSODesc</span><span class="p">.</span><span class="n">ResourceLayout</span><span class="p">.</span><span class="n">NumStaticSamplers</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">PSODesc</span><span class="p">.</span><span class="n">ResourceLayout</span><span class="p">.</span><span class="n">StaticSamplers</span>    <span class="o">=</span> <span class="o">&amp;</span><span class="n">StaticSampler</span><span class="p">;</span></pre><p>When all required fields of PSO description structure are set, call <code>IRenderDevice::CreateGraphicsPipelineState()</code> to create the PSO object:</p><pre class="m-code"><span class="n">m_pDevice</span><span class="o">-&gt;</span><span class="n">CreateGraphicsPipelineState</span><span class="p">(</span><span class="n">PSOCreateInfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_pPSO</span><span class="p">);</span></pre><p><a name="binding_resources"></a></p></section></section><section id="autotoc_md58"><h3><a href="#autotoc_md58">Binding Shader Resources</a></h3><p>As mentioned above, <a href="http://diligentgraphics.com/2016/03/23/resource-binding-model-in-diligent-engine-2-0/">shader resource binding in Diligent Engine</a> is based on grouping variables in 3 different groups (static, mutable and dynamic). Static variables are variables that are expected to be set only once. They may not be changed once a resource is bound to the variable. Such variables are intended to hold global constants such as camera attributes or global light attributes constant buffers. They are bound directly to the Pipeline State Object:</p><pre class="m-code"><span class="n">m_pPSO</span><span class="o">-&gt;</span><span class="n">GetStaticShaderVariable</span><span class="p">(</span><span class="n">SHADER_TYPE_PIXEL</span><span class="p">,</span> <span class="s">&quot;g_tex2DShadowMap&quot;</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Set</span><span class="p">(</span><span class="n">pShadowMapSRV</span><span class="p">);</span></pre><p>Mutable and dynamic variables are bound via a new object called Shader Resource Binding (SRB), which is created by the pipeline state (<code>IPipelineState::CreateShaderResourceBinding()</code>):</p><pre class="m-code"><span class="n">m_pPSO</span><span class="o">-&gt;</span><span class="n">CreateShaderResourceBinding</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_pSRB</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span></pre><p>The second parameter tells the system to initialize internal structures in the SRB object that reference static variables in the PSO.</p><p>Dynamic and mutable resources are then bound through SRB object:</p><pre class="m-code"><span class="n">m_pSRB</span><span class="o">-&gt;</span><span class="n">GetVariable</span><span class="p">(</span><span class="n">SHADER_TYPE_PIXEL</span><span class="p">,</span>  <span class="s">&quot;tex2DDiffuse&quot;</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Set</span><span class="p">(</span><span class="n">pDiffuseTexSRV</span><span class="p">);</span>
<span class="n">m_pSRB</span><span class="o">-&gt;</span><span class="n">GetVariable</span><span class="p">(</span><span class="n">SHADER_TYPE_VERTEX</span><span class="p">,</span> <span class="s">&quot;cbRandomAttribs&quot;</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Set</span><span class="p">(</span><span class="n">pRandomAttrsCB</span><span class="p">);</span></pre><p>The difference between mutable and dynamic resources is that mutable ones can only be set once for every instance of a shader resource binding. Dynamic resources can be set multiple times. It is important to properly set the variable type as this affects performance. Static variables are generally most efficient, followed by mutable. Dynamic variables are most expensive from performance point of view.</p><p>An alternative way to bind shader resources is to create <code>IResourceMapping</code> interface that maps resource literal names to the actual resources:</p><pre class="m-code"><span class="n">ResourceMappingEntry</span> <span class="n">Entries</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;g_Texture&quot;</span><span class="p">,</span> <span class="n">pTexture</span><span class="o">-&gt;</span><span class="n">GetDefaultView</span><span class="p">(</span><span class="n">TEXTURE_VIEW_SHADER_RESOURCE</span><span class="p">)},</span>
    <span class="n">ResourceMappingEntry</span><span class="p">{}</span>
<span class="p">};</span>
<span class="n">ResourceMappingDesc</span> <span class="n">ResMappingDesc</span><span class="p">;</span>
<span class="n">ResMappingDesc</span><span class="p">.</span><span class="n">pEntries</span><span class="o">=</span> <span class="n">Entries</span><span class="p">;</span>
<span class="n">RefCntAutoPtr</span><span class="o">&lt;</span><span class="n">IResourceMapping</span><span class="o">&gt;</span> <span class="n">pResMapping</span><span class="p">;</span>
<span class="n">pRenderDevice</span><span class="o">-&gt;</span><span class="n">CreateResourceMapping</span><span class="p">(</span> <span class="n">ResMappingDesc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pResMapping</span> <span class="p">);</span></pre><p>The resource mapping can then be used to bind all static resources in a pipeline state (<code>IPipelineState::BindStaticResources()</code>):</p><pre class="m-code"><span class="n">m_pPSO</span><span class="o">-&gt;</span><span class="n">BindStaticResources</span><span class="p">(</span><span class="n">SHADER_TYPE_VERTEX</span> <span class="o">|</span> <span class="n">SHADER_TYPE_PIXEL</span><span class="p">,</span> <span class="n">pResMapping</span><span class="p">,</span> <span class="n">BIND_SHADER_RESOURCES_VERIFY_ALL_RESOLVED</span><span class="p">);</span></pre><p>or all mutable and dynamic resources in a shader resource binding (<code>IShaderResourceBinding::BindResources()</code>):</p><pre class="m-code"><span class="n">m_pSRB</span><span class="o">-&gt;</span><span class="n">BindResources</span><span class="p">(</span><span class="n">SHADER_TYPE_VERTEX</span> <span class="o">|</span> <span class="n">SHADER_TYPE_PIXEL</span><span class="p">,</span> <span class="n">pResMapping</span><span class="p">,</span> <span class="n">BIND_SHADER_RESOURCES_VERIFY_ALL_RESOLVED</span><span class="p">);</span></pre><p>The last parameter to all <code>BindResources()</code> functions defines how resources should be resolved:</p><ul><li><code>BIND_SHADER_RESOURCES_UPDATE_STATIC</code> - Indicates that static variable bindings are to be updated.</li><li><code>BIND_SHADER_RESOURCES_UPDATE_MUTABLE</code> - Indicates that mutable variable bindings are to be updated.</li><li><code>BIND_SHADER_RESOURCES_UPDATE_DYNAMIC</code> -Indicates that dynamic variable bindings are to be updated.</li><li><code>BIND_SHADER_RESOURCES_UPDATE_ALL</code> - Indicates that all variable types (static, mutable and dynamic) are to be updated. Note that if none of <code>BIND_SHADER_RESOURCES_UPDATE_STATIC</code>, <code>BIND_SHADER_RESOURCES_UPDATE_MUTABLE</code>, and <code>BIND_SHADER_RESOURCES_UPDATE_DYNAMIC</code> flags are set, all variable types are updated as if <code>BIND_SHADER_RESOURCES_UPDATE_ALL</code> was specified.</li><li><code>BIND_SHADER_RESOURCES_KEEP_EXISTING</code> - If this flag is specified, only unresolved bindings will be updated. All existing bindings will keep their original values. If this flag is not specified, every shader variable will be updated if the mapping contains corresponding resource.</li><li><code>BIND_SHADER_RESOURCES_VERIFY_ALL_RESOLVED</code> - If this flag is specified, all shader bindings are expected be resolved after the call. If this is not the case, an error will be reported.</li></ul><p><code>BindResources()</code> may be called several times with different resource mappings to bind resources. However, it is recommended to use one large resource mapping as the size of the mapping does not affect element search time.</p><p>The engine performs run-time checks to verify that correct resources are being bound. For example, if you try to bind a constant buffer to a shader resource view variable, an error will be output to the debug console.</p><p><a name="draw_command"></a></p></section><section id="autotoc_md59"><h3><a href="#autotoc_md59">Setting the Pipeline State and Invoking Draw Command</a></h3><p>Before any draw command can be invoked, all required vertex and index buffers as well as the pipeline state should be bound to the device context:</p><pre class="m-code"><span class="c1">// Set render targets before issuing any draw command.</span>
<span class="k">auto</span><span class="o">*</span> <span class="n">pRTV</span> <span class="o">=</span> <span class="n">m_pSwapChain</span><span class="o">-&gt;</span><span class="n">GetCurrentBackBufferRTV</span><span class="p">();</span>
<span class="k">auto</span><span class="o">*</span> <span class="n">pDSV</span> <span class="o">=</span> <span class="n">m_pSwapChain</span><span class="o">-&gt;</span><span class="n">GetDepthBufferDSV</span><span class="p">();</span>
<span class="n">m_pContext</span><span class="o">-&gt;</span><span class="n">SetRenderTargets</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pRTV</span><span class="p">,</span> <span class="n">pDSV</span><span class="p">,</span> <span class="n">RESOURCE_STATE_TRANSITION_MODE_TRANSITION</span><span class="p">);</span>

<span class="c1">// Clear render target and depth-stencil</span>
<span class="k">const</span> <span class="kt">float</span> <span class="n">zero</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
<span class="n">m_pContext</span><span class="o">-&gt;</span><span class="n">ClearRenderTarget</span><span class="p">(</span><span class="n">pRTV</span><span class="p">,</span> <span class="n">ClearColor</span><span class="p">,</span> <span class="n">RESOURCE_STATE_TRANSITION_MODE_TRANSITION</span><span class="p">);</span>
<span class="n">m_pContext</span><span class="o">-&gt;</span><span class="n">ClearDepthStencil</span><span class="p">(</span><span class="n">pDSV</span><span class="p">,</span> <span class="n">CLEAR_DEPTH_FLAG</span><span class="p">,</span> <span class="mf">1.f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">RESOURCE_STATE_TRANSITION_MODE_TRANSITION</span><span class="p">);</span>

<span class="c1">// Set vertex and index buffers</span>
<span class="n">IBuffer</span><span class="o">*</span> <span class="n">buffer</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">m_pVertexBuffer</span><span class="p">};</span>
<span class="n">Uint32</span> <span class="n">offsets</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="n">m_pContext</span><span class="o">-&gt;</span><span class="n">SetVertexBuffers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">SET_VERTEX_BUFFERS_FLAG_RESET</span><span class="p">,</span>
                             <span class="n">RESOURCE_STATE_TRANSITION_MODE_TRANSITION</span><span class="p">);</span>
<span class="n">m_pContext</span><span class="o">-&gt;</span><span class="n">SetIndexBuffer</span><span class="p">(</span><span class="n">m_pIndexBuffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">RESOURCE_STATE_TRANSITION_MODE_TRANSITION</span><span class="p">);</span>

<span class="n">m_pContext</span><span class="o">-&gt;</span><span class="n">SetPipelineState</span><span class="p">(</span><span class="n">m_pPSO</span><span class="p">);</span></pre><p>All methods that may need to perform resource state transitions take <code>RESOURCE_STATE_TRANSITION_MODE</code> enum as parameter. The enum defines the following modes:</p><ul><li><code>RESOURCE_STATE_TRANSITION_MODE_NONE</code> - Perform no resource state transitions.</li><li><code>RESOURCE_STATE_TRANSITION_MODE_TRANSITION</code> - Transition resources to the states required by the command.</li><li><code>RESOURCE_STATE_TRANSITION_MODE_VERIFY</code> - Do not transition, but verify that states are correct.</li></ul><p>The final step is to committ shader resources to the device context. This is accomplished by the <code>IDeviceContext::CommitShaderResources()</code> method:</p><pre class="m-code"><span class="n">m_pContext</span><span class="o">-&gt;</span><span class="n">CommitShaderResources</span><span class="p">(</span><span class="n">m_pSRB</span><span class="p">,</span> <span class="n">COMMIT_SHADER_RESOURCES_FLAG_TRANSITION_RESOURCES</span><span class="p">);</span></pre><p>If the method is not called, the engine will detect that resources are not committed and output debug message. Note that <code>CommitShaderResources()</code> must be called after the right pipeline state has been bound to the context. Note that the last parameter tells the system to transition resources to correct states. If this flag is not specified, the resources must be explicitly transitioned to required states by a call to <code>IDeviceContext::TransitionShaderResources()</code>:</p><pre class="m-code"><span class="n">m_pContext</span><span class="o">-&gt;</span><span class="n">TransitionShaderResources</span><span class="p">(</span><span class="n">m_pPSO</span><span class="p">,</span> <span class="n">m_pSRB</span><span class="p">);</span></pre><p>Note that the method requires pointer to the pipeline state that created the shader resource binding.</p><p>When all required states and resources are bound, <code>IDeviceContext::Draw()</code> can be used to execute draw command or <code>IDeviceContext::DispatchCompute()</code> can be used to execute compute command. Note that for a draw command, graphics pipeline must be bound, and for dispatch command, compute pipeline must be bound. <code>Draw()</code> takes <code>DrawAttribs</code> structure as an argument. The structure members define all attributes required to perform the command (number of vertices or indices, if draw call is indexed or not, if draw call is instanced or not, if draw call is indirect or not, etc.). For example:</p><pre class="m-code"><span class="n">DrawAttribs</span> <span class="n">attrs</span><span class="p">;</span>
<span class="n">attrs</span><span class="p">.</span><span class="n">IndexType</span>  <span class="o">=</span> <span class="n">VT_UINT16</span><span class="p">;</span>
<span class="n">attrs</span><span class="p">.</span><span class="n">NumIndices</span> <span class="o">=</span> <span class="mi">36</span><span class="p">;</span>
<span class="n">attrs</span><span class="p">.</span><span class="n">Flags</span>      <span class="o">=</span> <span class="n">DRAW_FLAG_VERIFY_STATES</span><span class="p">;</span>
<span class="n">pContext</span><span class="o">-&gt;</span><span class="n">Draw</span><span class="p">(</span><span class="n">attrs</span><span class="p">);</span></pre><p><code>DRAW_FLAG_VERIFY_STATES</code> flag instructs the engine to verify that vertex and index buffers used by the draw command are transitioned to proper states.</p><p><code>DispatchCompute()</code> takes DispatchComputeAttribs structure that defines compute grid dimensions:</p><pre class="m-code"><span class="n">m_pContext</span><span class="o">-&gt;</span><span class="n">SetPipelineState</span><span class="p">(</span><span class="n">m_pComputePSO</span><span class="p">);</span>
<span class="n">m_pContext</span><span class="o">-&gt;</span><span class="n">CommitShaderResources</span><span class="p">(</span><span class="n">m_pComputeSRB</span><span class="p">,</span> <span class="n">COMMIT_SHADER_RESOURCES_FLAG_TRANSITION_RESOURCES</span><span class="p">);</span>
<span class="n">DispatchComputeAttribs</span> <span class="nf">DispatchAttrs</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
<span class="n">m_pContext</span><span class="o">-&gt;</span><span class="n">DispatchCompute</span><span class="p">(</span><span class="n">DispatchAttrs</span><span class="p">);</span></pre><p>You can learn more about the engine API by looking at the <a href="https://github.com/DiligentGraphics/DiligentSamples">engine samples&#x27; source code</a> and the [API Reference][1].</p><p><a name="low_level_api_interoperability"></a></p></section></section><section id="autotoc_md60"><h2><a href="#autotoc_md60">Low-level API interoperability</a></h2><p><a href="namespaceDiligent.html" class="m-doc">Diligent</a> Engine extensively supports interoperability with underlying low-level APIs. The engine can be initialized by attaching to existing D3D11/D3D12 device or OpenGL/GLES context and provides access to the underlying native API objects. Refer to the following pages for more information:</p><p><a href="http://diligentgraphics.com/diligent-engine/native-api-interoperability/direct3d11-interoperability/">Direct3D11 Interoperability</a></p><p><a href="http://diligentgraphics.com/diligent-engine/native-api-interoperability/direct3d12-interoperability/">Direct3D12 Interoperability</a></p><p><a href="http://diligentgraphics.com/diligent-engine/native-api-interoperability/openglgles-interoperability/">OpenGL/GLES Interoperability</a></p><p><a name="repository_structure"></a></p></section><section id="autotoc_md61"><h2><a href="#autotoc_md61">Repository structure</a></h2><p>The repository contains the following projects:</p><table class="m-table"><thead><tr><th>Project</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://github.com/DiligentGraphics/DiligentCore/tree/master/Primitives">Primitives</a></td><td>Definitions of basic types (Int32, Int16, Uint32, etc.) and interfaces (IObject, IReferenceCounters, etc.)</td></tr><tr><td><a href="https://github.com/DiligentGraphics/DiligentCore/tree/master/Common">Common</a></td><td>Common functionality such as file wrapper, logging, debug utilities, etc.</td></tr><tr><td><a href="https://github.com/DiligentGraphics/DiligentCore/tree/master/Graphics/GraphicsAccessories">Graphics/<wbr />GraphicsAccessories</a></td><td>Basic graphics accessories used by all implementations</td></tr><tr><td><a href="https://github.com/DiligentGraphics/DiligentCore/tree/master/Graphics/GraphicsEngine">Graphics/<wbr />GraphicsEngine</a></td><td>Platform-independent base functionality</td></tr><tr><td><a href="https://github.com/DiligentGraphics/DiligentCore/tree/master/Graphics/GraphicsEngineD3DBase">Graphics/<wbr />GraphicsEngineD3DBase</a></td><td>Base functionality for D3D11/D3D12 implementations</td></tr><tr><td><a href="https://github.com/DiligentGraphics/DiligentCore/tree/master/Graphics/GraphicsEngineD3D11">Graphics/<wbr />GraphicsEngineD3D11</a></td><td>Implementation of Direct3D11 rendering backend</td></tr><tr><td><a href="https://github.com/DiligentGraphics/DiligentCore/tree/master/Graphics/GraphicsEngineD3D12">Graphics/<wbr />GraphicsEngineD3D12</a></td><td>Implementation of Direct3D12 rendering backend</td></tr><tr><td><a href="https://github.com/DiligentGraphics/DiligentCore/tree/master/Graphics/GraphicsEngineOpenGL">Graphics/<wbr />GraphicsEngineOpenGL</a></td><td>Implementation of OpenGL/GLES rendering backend</td></tr><tr><td><a href="https://github.com/DiligentGraphics/DiligentCore/tree/master/Graphics/GraphicsEngineVulkan">Graphics/<wbr />GraphicsEngineVulkan</a></td><td>Implementation of Vulkan rendering backend</td></tr><tr><td><a href="https://github.com/DiligentGraphics/DiligentCore/tree/master/Graphics/GraphicsEngineMetal">Graphics/<wbr />GraphicsEngineMetal</a></td><td>Implementation of Metal rendering backend</td></tr><tr><td><a href="https://github.com/DiligentGraphics/DiligentCore/tree/master/Graphics/GraphicsTools">Graphics/<wbr />GraphicsTools</a></td><td>Graphics utilities build on top of core interfaces (definitions of commonly used states, texture uploaders, etc.)</td></tr><tr><td><a href="https://github.com/DiligentGraphics/DiligentCore/tree/master/Graphics/HLSL2GLSLConverterLib">Graphics/<wbr />HLSL2GLSLConverterLib</a></td><td>HLSL to GLSL source code converter library</td></tr><tr><td><a href="https://github.com/DiligentGraphics/DiligentCore/tree/master/Platforms/Basic">Platforms/<wbr />Basic</a></td><td>Interface for platform-specific routines and implementation of some common functionality</td></tr><tr><td><a href="https://github.com/DiligentGraphics/DiligentCore/tree/master/Platforms/Android">Platforms/<wbr />Android</a></td><td>Implementation of platform-specific routines on Android</td></tr><tr><td><a href="https://github.com/DiligentGraphics/DiligentCore/tree/master/Platforms/Apple">Platforms/<wbr />Apple</a></td><td>Implementation of platform-specific routines on Apple platforms (MacOS, iOS)</td></tr><tr><td><a href="https://github.com/DiligentGraphics/DiligentCore/tree/master/Platforms/UWP">Platforms/<wbr />UWP</a></td><td>Implementation of platform-specific routines on Universal Windows platform</td></tr><tr><td><a href="https://github.com/DiligentGraphics/DiligentCore/tree/master/Platforms/Win32">Platforms/<wbr />Win32</a></td><td>Implementation of platform-specific routines on Win32 platform</td></tr><tr><td><a href="https://github.com/DiligentGraphics/DiligentCore/tree/master/Platforms/Linux">Platforms/<wbr />Linux</a></td><td>Implementation of platform-specific routines on Linux platform</td></tr><tr><td>External</td><td>Third-party libraries and modules</td></tr></tbody></table></section><section id="autotoc_md62"><h2><a href="#autotoc_md62">License</a></h2><p>See <a href="License.txt">Apache 2.0 license</a>.</p><p>This project has some third-party dependencies, each of which may have independent licensing:</p><ul><li><a href="https://github.com/KhronosGroup/Vulkan-Headers">Vulkan-Headers</a>: Vulkan Header files and API registry (<a href="https://github.com/DiligentGraphics/Vulkan-Headers/blob/master/LICENSE.txt">Apache License 2.0</a>).</li><li><a href="https://github.com/KhronosGroup/SPIRV-Cross">SPIRV-Cross</a>: SPIRV parsing and cross-compilation tools (<a href="https://github.com/DiligentGraphics/SPIRV-Cross/blob/master/LICENSE">Apache License 2.0</a>).</li><li><a href="https://github.com/KhronosGroup/SPIRV-Headers">SPIRV-Headers</a>: SPIRV header files (<a href="https://github.com/DiligentGraphics/SPIRV-Headers/blob/master/LICENSE">Khronos MIT-like license</a>).</li><li><a href="https://github.com/KhronosGroup/SPIRV-Tools">SPIRV-Tools</a>: SPIRV optimization and validation tools (<a href="https://github.com/DiligentGraphics/SPIRV-Tools/blob/master/LICENSE">Apache License 2.0</a>).</li><li><a href="https://github.com/KhronosGroup/glslang">glslang</a>: Khronos reference compiler and validator for GLSL, ESSL, and HLSL (<a href="https://github.com/DiligentGraphics/glslang/blob/master/LICENSE.txt">3-Clause BSD License, 2-Clause BSD License, MIT, Apache License 2.0</a>).</li><li><a href="http://glew.sourceforge.net/">glew</a>: OpenGL Extension Wrangler Library (<a href="https://github.com/DiligentGraphics/DiligentCore/blob/master/ThirdParty/glew/LICENSE.txt">Mesa 3-D graphics library, Khronos MIT-like license</a>).</li><li><a href="https://github.com/zeux/volk">volk</a>: Meta loader for Vulkan API (<a href="https://github.com/DiligentGraphics/volk/blob/master/LICENSE.md">Arseny Kapoulkine MIT-like license</a>).</li><li><a href="https://github.com/nothings/stb">stb</a>: stb single-file public domain libraries for C/C++ (<a href="https://github.com/DiligentGraphics/DiligentCore/blob/master/ThirdParty/stb/stb_image_write.h#L1581">MIT License or public domain</a>).</li><li><a href="https://github.com/google/googletest">googletest</a>: Google Testing and Mocking Framework (<a href="https://github.com/DiligentGraphics/googletest/blob/master/LICENSE">BSD 3-Clause &quot;New&quot; or &quot;Revised&quot; License</a>).</li><li><a href="https://github.com/microsoft/DirectXShaderCompiler">DirectXShaderCompiler</a>: LLVM/Clang-based DirectX Shader Compiler (<a href="https://github.com/DiligentGraphics/DiligentCore/blob/master/ThirdParty/DirectXShaderCompiler/LICENSE.TXT">LLVM Release License</a>).</li><li><a href="ThirdParty/GPUOpenShaderUtils">DXBCChecksum</a>: DXBC Checksum computation algorithm by AMD Developer Tools Team (<a href="ThirdParty/GPUOpenShaderUtils/License.txt">MIT lincesne</a>).</li></ul><p><a name="contributing"></a></p></section><section id="autotoc_md63"><h2><a href="#autotoc_md63">Contributing</a></h2><p>To contribute your code, submit a <a href="https://github.com/DiligentGraphics/DiligentCore/pulls">Pull Request</a> to this repository. <strong><a href="namespaceDiligent.html" class="m-doc">Diligent</a> Engine</strong> is distributed under the <a href="License.txt">Apache 2.0 license</a> that guarantees that content in the <strong>DiligentCore</strong> repository is free of Intellectual Property encumbrances. In submitting any content to this repository, <a href="https://docs.github.com/en/free-pro-team@latest/github/site-policy/github-terms-of-service#6-contributions-under-repository-license">you license that content under the same terms</a>, and you agree that the content is free of any Intellectual Property claims and you have the right to license it under those terms.</p><p><a href="namespaceDiligent.html" class="m-doc">Diligent</a> Engine uses <a href="https://clang.llvm.org/docs/ClangFormat.html">clang-format</a> to ensure consistent source code style throught the code base. The format is validated by appveyor and travis for each commit and pull request, and the build will fail if any code formatting issue is found. Please refer to <a href="https://github.com/DiligentGraphics/DiligentCore/blob/master/doc/code_formatting.md">this page</a> for instructions on how to set up clang-format and automatic code formatting.</p><p><a name="references"></a></p></section><section id="autotoc_md64"><h2><a href="#autotoc_md64">References</a></h2><p><a href="http://diligentgraphics.com/diligent-engine/architecture/">Diligent Engine Architecture</a></p><p><a href="http://diligentgraphics.com/diligent-engine/api-basics/">API Basics</a></p><p><a name="release_history"></a></p></section><section id="autotoc_md65"><h2><a href="#autotoc_md65">Release History</a></h2><p>See Release History</p><hr/><p><a href="http://diligentgraphics.com">diligentgraphics.com</a></p></section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form>
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or
            modules. You can omit any prefix from the symbol or file path; adding a
            <code>:</code> or <code>/</code> suffix lists all members of given symbol or
            directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span>
            / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
            <span class="m-label m-dim">Enter</span> to go.
            <span class="m-label m-dim">Tab</span> autocompletes common prefix, you can
            copy a link to the result using <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">L</span> while <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">M</span> produces a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v1.js"></script>
<script src="searchdata-v1.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Diligent Engine. Created with <a href="https://doxygen.org/">Doxygen</a> 1.8.17 and <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>
